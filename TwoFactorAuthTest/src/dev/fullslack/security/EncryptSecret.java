package dev.fullslack.security;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.security.auth.Destroyable;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.*;

public class EncryptSecret {

    private static final int AUTH_TAG_SIZE = 128; // bits

    private static final int IV_LEN = 12; // bytes

    // number of random number bytes generated before re-seeding
    private static final double PRNG_RESEED_INTERVAL = Math.pow(2, 16);

    private static final String ENCRYPT_ALGO = "AES/GCM/NoPadding";

    private static final List<Integer> ALLOWED_KEY_SIZES = Arrays.asList(
            new Integer[] {128, 192, 256}); // bits

    private static final String ALGORITHM = "AES";

    private static SecureRandom prng;

    // Used to keep track of random number bytes generated by PRNG
    // (for the purpose of re-seeding)
    private static int bytesGenerated = 0;

    public String encrypt(String input, String keyInput) throws Exception {
        Objects.requireNonNull(input, "Input message cannot be null");
        Objects.requireNonNull(keyInput, "Key cannot be null");

        if (input.length() == 0) {
            throw new IllegalArgumentException("Length of message cannot be 0");
        }

        SecretKeySpec key = decodeSecretKeySpecString(keyInput);

        if (!ALLOWED_KEY_SIZES.contains(key.getEncoded().length * 8)) {
            throw new IllegalArgumentException("Size of key must be 128, 192 or 256");
        }

        byte[] inputBytes = input.getBytes(StandardCharsets.UTF_8);

        Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);

        byte[] iv = getIV(IV_LEN);

        GCMParameterSpec gcmParamSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);

        cipher.init(Cipher.ENCRYPT_MODE, key, gcmParamSpec);
        byte[] messageCipher = cipher.doFinal(inputBytes);

        // Prepend the IV with the message cipher
        byte[] cipherText = new byte[messageCipher.length + IV_LEN];
        System.arraycopy(iv, 0, cipherText, 0, IV_LEN);
        System.arraycopy(messageCipher, 0, cipherText, IV_LEN, messageCipher.length);
        return Base64.getEncoder().encodeToString(cipherText);
    }

    public String decrypt(String input, String keyInput) throws Exception {
        Objects.requireNonNull(input, "Input message cannot be null");
        Objects.requireNonNull(keyInput, "Key cannot be null");

        if (input.length() == 0) {
            throw new IllegalArgumentException("Length of message cannot be 0");
        }

        SecretKeySpec key = decodeSecretKeySpecString(keyInput);

        byte[] inputBytes = Base64.getDecoder().decode(input);

        byte[] iv = new byte[IV_LEN];
        System.arraycopy(inputBytes, 0, iv, 0, IV_LEN);

        byte[] messageCipher = new byte[inputBytes.length - IV_LEN];
        System.arraycopy(inputBytes, IV_LEN, messageCipher, 0, inputBytes.length - IV_LEN);

        GCMParameterSpec gcmParamSpec = new GCMParameterSpec(AUTH_TAG_SIZE, iv);

        Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);
        cipher.init(Cipher.DECRYPT_MODE, key, gcmParamSpec);

        return new String(cipher.doFinal(messageCipher), StandardCharsets.UTF_8);
    }

    private byte[] getIV(int bytesNum) {
        if (bytesNum < 1) {
            throw new IllegalArgumentException("Number of bytes must be greater than 0");
        }

        byte[] iv = new byte[bytesNum];

        prng = Optional.ofNullable(prng).orElseGet(() -> {
            try {
                prng = SecureRandom.getInstanceStrong();
            } catch (NoSuchAlgorithmException ex) {
                throw new RuntimeException("Wrong algorithm name", ex);
            }
            return prng;
        });

        if ((bytesGenerated > PRNG_RESEED_INTERVAL) || (bytesGenerated == 0)) {
            prng.setSeed(prng.generateSeed(bytesNum));
            bytesGenerated = 0;
        }

        prng.nextBytes(iv);
        bytesGenerated = bytesGenerated + bytesNum;

        return iv;
    }

    private static void clearSecret(Destroyable key) throws Exception {
        Field keyField = key.getClass().getDeclaredField("key");
        keyField.setAccessible(true);
        byte[] encodedKey = (byte[]) keyField.get(key);
        Arrays.fill(encodedKey, Byte.MIN_VALUE);
    }

    public String createSecretKeySpec() throws NoSuchAlgorithmException {
        return createSecretKeySpec(256);
    }

    public String createSecretKeySpec(int keySize) throws NoSuchAlgorithmException {
        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);
        keyGen.init(keySize, SecureRandom.getInstanceStrong());

        SecretKey secretKey = keyGen.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), ALGORITHM);
        return Base64.getEncoder().encodeToString(secretKeySpec.getEncoded());
    }

    private SecretKeySpec decodeSecretKeySpecString(String input) {
        SecretKeySpec secretKeySpec = new SecretKeySpec(Base64.getDecoder().decode(input), ALGORITHM);
        return secretKeySpec;
    }
}
